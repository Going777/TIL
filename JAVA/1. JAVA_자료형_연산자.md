Aug 7 01:12:58 2022 +0900

# 컴퓨터 자료 표현

비트 (Bit): 컴퓨터가 값을 저장할 수 있는 최소 단위

바이트 (Byte): 컴퓨터가 정보를 처리하기 위한 최소 단위  `1바이트 = 8비트`

2진수 (Binary): 컴퓨터가 표현하는 방식

### JVM

- 자바 바이트코드를 실행할 수 있는 주체 (컴파일 된 바이트코드를 가져와서 각 운영체제에서 실행시켜줌)
- 자바 바이트코드는 플랫폼에 독립적이며 모든 JVM은 자바 가상 머신 규격에 정의된대로 자바 바이트 코드를 실행

### JRE

- 실행시 필요한 것

### JDK

- JRE + 개발에 필요한 도구들(컴파일러…)

# JAVA 기본

### main method → main 작성하고 `Ctrl+spacebar`누르면 자동완성 가능

```java
public static void main(String[] args) { }
```

- 실행 명령인 java를 작성하고 실행하면 가장 먼저 호출 되는 부분
- 만약 Application에서 main() 메소드가 없다면 절대로 실행될 수 없다
- Application의 시작 → 특정 클래스이 main() 실행
- 고정된 형태

### 주석 `Ctrl+/`

- // : 해당 기호가 등장한 순간부터 끝까지 해당 줄을 주석처리 (한 줄 주석)
- /*  */ : 해당 범위를 주석처리 (여러 줄 주석)
- /**   */ : Documentation API를 위한 주석 (매서드 혹은 클래스를 설명)

### 출력문 → sysout 작성하고 `Ctrl+spacebar` 누르면 println 옵션으로 자동완성

- print : 한 줄 출력 (줄바꿈 안해줌)
- println : 출력 후 알아서 줄바꿈
- printf : 프린트 형식에 포맷을 줄 수 있음
    - %d : 정수
    - %f : 실수
    - %c : 문자
    - %s : 문자열

# 변수와 자료형

### 변수

- 데이터를 저장할 메모리의 위치를 나타내는 이름
- 메모리 상에 데이터를 보관할 수 있는 공간을 확보
- 적절한 메모리 공간을 확보하기 위해 **변수의 타입** 등장
- `=`(할당 연산자)을 통해 CPU에게 연산작업을 의뢰
- 대소문자 구분 / 공백 허용X / 숫자로 시작 불가 / `$` 와 `_` 는 변수이름에 사용 가능(이외 특수문자는 불가능) / 한글 가능가능하나 지양 / 합성어의 경우 camelCase활용
- 예약어는 사용 불가
- 선언 `자료형 변수명;`
- 저장(할당) `변수명 = 저장할 값;`
- 초기화 `자료형 변수명 = 저장할 값;`

```java
int a;	//선언
a = 1;  // 할당
double b = 2.2;  // 초기화
```

### 자료형 (Data Type) - 데이터 타입이 메모리 소모 양을 결정짓는다

1. 기본 자료형 
- 미리 정해진 크기의 메모리 사이즈 표현, **변수 자체에 값을 저장**
- 일반적으로 정수는 int, 실수는 double을 사용하도록 권장
- 문자(char)은 기본 자료형이지만, 문자열(String)은 참조 자료형

![image](https://user-images.githubusercontent.com/109488657/183258167-4d3bf18e-d017-4c7a-83d6-9c581cb6bbc9.png)

1. 참조 자료형 
- 기본 자료형 8가지 외 모든 것 (string 포함), **변수 자체에 주소값을 저장**

### 자료형 크기 비교

```java
byte(1byte) < short, char(2byte) < int(4byte) < long(8byte) < float(4byte) < double(8byte)

# long보다 float(실수)의 크기가 더 작지만 표현범위가 float이 훨씬 크다 
# (실수형은 부정확한 대신 범위가 엄청나게 큰 수를 저장할 수 있다)
# short는 음수 허용하지만, char는 음수 비허용
```

### 데이터 형변환 (Type Conversion)

1. 묵시적(암묵적) 형변환 
- 범위가 넓은 데이터 형에 좁은 데이터 형을 대입하는 경우
- 정보의 손실이 발생하지 않는 경우에만 자동으로 형변환 가능

```java
double a = 3.0F;
# 실수값을 기본적으로 double형이다
# 이때 3.0F는 3.0이라는 실수를 강제로 float형으로 바꾸겠다는 의미이다
# a는 double형으로 선언되어 있고, 뒤의 상수는 float형인데 오류가 발생하지 않는다
# double이 float보다 더 많은 데이터를 표현할 수 있기 때문에
# 자바가 float에서 double로 자동으로 형 변환해준 것

float a = 3.0;
# 오류 발생
# float보다 double이 더 많은 데이터를 표현할 수 있으므로
# 정보 손실을 우려하여 자동으로 형 변환 해주지 않음

int a = 3;
float b = 1.0F;
double c = a + b;
# a와 b를 더하기 위해서는 형이 같아야 한다
# 더 작은 범위인 int형이 float형으로 자동 형변환 된다 -> 3.0F + 1.0F = 4.0F
# 위 결과를 더 큰 범위인 double형에 할당하고 있으므로 자동 형변환되어
# 최종적으로 c에는 4.0 double형이 할당된다
```

1. 명시적 형변환 
- 범위가 좁은 데이터 형에 넓은 데이터 형을 대입하는 경우
- 데이터 손실 가능성이 존재함

```java
float a = 100.0;
int b = 100.0F;
# 두 경우 모두 에러 발생

# 상수값 앞에 특정 형을 강제로 할당함으로써 오류 해결
float a = (float) 100.0;
int b = (int) 100.0F;

# 만약 (int) 100.2F 였다면, 최종적으로 100이 할당됨 
# (소수점 자리는 삭제되어 정보 손실 발생)
```

# 연산자

1. 단항 연산자 `n++` `n--` `+n` `-n` `!` `~` `(type)`
2. 산술 연산자 `+` `-` `*` `/` `%` 

```java
int a = 10;
int b = 3;
float c = 10.0F;
float d = 3.0F;

System.out.println(a/b); // 3
System.out.println(c/d); // 3.3333333
System.out.println(a/d); // 3.3333333
# 정수/정수 => 소수점 이하 값 버리고 정수값만 출력
# 실수/실수 => 소수점 포함하여 실수값 그대로 출력
# 정수/실수 => 연산을 위해선 형이 같아야 하기 때문에 더 작은 범위인 정수를 실수형으로 바꿔주고, 최종적으로 실수값 그대로 출력
```

1. 비교 연산자 `==` `!=` `instanceof` `.equals`

```java
String a = "Hello";
String b = new String("Hello");
System.out.println(a == b);  // false
System.out.println(a.equals(b))  // true
# 문자열 비교를 위해서는 .equals()를 사용해야 한다
```

1. 논리 연산자 `&&` `||` `!`
2. 삼항 연산자 `조건식 ? 식1 : 식2`
3. 복합 대입 연산자 `+=` `-=` `*=` `/=`
